<!doctype html>
<html lang="en" data-theme="light">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="color-scheme" content="light dark" />
<title>_Wall.txt</title>

<!-- Set initial theme ASAP to avoid flash -->
<script>
  (function () {
    try {
      const KEY = 'nw-theme';
      const saved = localStorage.getItem(KEY);
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const initial = saved || (prefersDark ? 'dark' : 'light');
      document.documentElement.setAttribute('data-theme', initial);
    } catch (_) {}
  })();
</script>

<style>
  /* ======= Plain, text-first aesthetic with theme variables ======= */
  * { box-sizing: border-box; }
  :root {
    --bg:#fff; --text:#000; --border:#000; --muted:#444; --maxw:860px;
    --vh: 100vh; /* updated by JS; falls back to 100vh */
  }
  /* Dark theme overrides */
  :root[data-theme="dark"] {
    --bg:#000; --text:#fff; --border:#fff; --muted:#bbb;
  }
  /* Respect system preference when user hasn't chosen (optional) */
  @media (prefers-color-scheme: dark) {
    :root:not([data-theme]), :root[data-theme="system"] {
      --bg:#000; --text:#fff; --border:#fff; --muted:#bbb;
    }
  }
  @supports (height: 100dvh) { :root { --vh: 100dvh; } }

  html, body { height: 100%; overflow-x: hidden; }  /* prevent sideways scroll */
  body {
    margin: 0;
    font: 16px/1.5 "Times New Roman", Times, serif;
    background: var(--bg);
    color: var(--text);
    height: var(--vh);
    display: grid;
    grid-template-rows: auto 1fr auto; /* header grows if needed */
    overflow: hidden; /* vertical scroll confined to <main> */
  }

  a { color: inherit; }
  a:hover { text-decoration: underline; }

  /* Generic container with safe-area padding */
  .wrap {
    width: 100%;
    max-width: var(--maxw);
    margin: 0 auto;
    padding-left: max(12px, env(safe-area-inset-left));
    padding-right: max(12px, env(safe-area-inset-right));
  }

  /* Header */
  header {
    border-bottom: 1px solid var(--border);
    background: var(--bg);
    padding-top: 10px;    /* breathing room above the title */
    padding-bottom: 6px;  /* a little space before the border */
  }
  .head-row {
    display: flex;
    align-items: center;  /* vertically center title within row */
    gap: 12px;
    min-height: 56px;     /* classic toolbar height feel */
  }
  .head-row h1 {
    font: bold 18px/1 "Times New Roman", Times, serif;
    margin: 0;
  }

  /* Theme toggle button (plain, text-first) */
  #themeToggle {
    margin-left: auto;
    font: inherit;
    line-height: 1;
    -webkit-appearance: none; appearance: none;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--text);
    border-radius: 0;
    height: 32px;
    padding: 0 10px;
    cursor: pointer;
  }

  #presence, #typing {
    font-size: 13px; color: var(--muted);
    margin: 4px 0 0 0;
    overflow-wrap: anywhere;  /* wrap long lists; no sideways push */
  }

  /* Main (scroll area) */
  main {
    min-height: 0;             /* enables scrolling inside this grid row */
    overflow: auto;
    border-left: 1px solid var(--border);
    border-right: 1px solid var(--border);
    -webkit-overflow-scrolling: touch;
    background: var(--bg);
  }
  #log { padding: 8px 12px 12px 12px; }
  #loadMore {
    display: none;
    margin: 8px 0 12px 0;
    background: transparent;
    border: 1px solid var(--border);
    padding: 4px 8px;
    font-size: 14px;
    cursor: pointer;
  }

  /* Messages: plain lines */
  .msg {
    padding: 6px 0;
    border-bottom: 1px solid var(--border);
    word-wrap: break-word; overflow-wrap: anywhere;
    background: transparent;
  }
  .time { color: var(--muted); }
  .name { font-weight: bold; }
  .body { white-space: pre-wrap; }

  /* Footer / composer */
  footer {
    border-top: 1px solid var(--border);
    background: var(--bg);
    padding: 10px 0 calc(10px + env(safe-area-inset-bottom)); /* space from border + safe area */
  }
  .composer {
    display: flex;
    gap: 8px;
    align-items: flex-end; /* align bottoms cleanly */
    flex-wrap: wrap;       /* allow wrapping on narrow phones instead of overflow */
  }

  /* Inputs/buttons: uniform height + shrink behavior */
  #chat input[type="text"], #chat button {
    font: inherit;
    line-height: 1;
    -webkit-appearance: none; appearance: none;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--text);
    border-radius: 0;
    height: 40px;       /* good touch size */
    padding: 0 10px;    /* vertical padding 0 with fixed height */
    max-width: 100%;
  }
  #chat input::placeholder { color: var(--muted); }

  /* Critical for preventing sideways overflow in flex rows */
  .composer, #name, #body { min-width: 0; }

  #name { flex: 0 1 180px; min-width: 110px; }
  #body { flex: 1 1 auto; }                 /* grows/shrinks as needed */
  #send { flex: 0 0 auto; white-space: nowrap; cursor: pointer; }

  /* If the row is too tight, let Send drop to its own line */
  @media (max-width: 420px) {
    #send { width: 100%; margin-top: 6px; }
    .wrap { padding-left: max(8px, env(safe-area-inset-left));
            padding-right: max(8px, env(safe-area-inset-right)); }
  }

  /* Firefox inner focus padding removal */
  button::-moz-focus-inner { border: 0; padding: 0; }
  small.help { display: block; margin-top: 6px; color: var(--muted); font-size: 13px; }
</style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="head-row">
        <h1>_Wall.txt</h1>
        <button id="themeToggle" aria-label="Toggle dark mode" aria-pressed="false">Dark mode</button>
      </div>
      <div id="presence" aria-live="polite"></div>
      <div id="typing" aria-live="polite"></div>
    </div>
  </header>

  <main>
    <div id="log" class="wrap" aria-live="polite">
      <button id="loadMore">Load older messages</button>
      <!-- messages insert here -->
    </div>
  </main>

  <footer>
    <div class="wrap">
      <form id="chat" class="composer" autocomplete="off">
        <input type="text" name="name" id="name" placeholder="Name" required />
        <input type="text" name="body" id="body" placeholder="Say something…" maxlength="1000" required />
        <button id="send" type="submit">Send</button>
      </form>
    </div>
  </footer>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="./config.js"></script>
  <script>
    // --- Dynamic viewport height: keeps layout stable with mobile keyboard ---
    (function setDynamicVh(){
      const root = document.documentElement;
      function updateVH(){
        if (window.visualViewport) {
          root.style.setProperty('--vh', window.visualViewport.height + 'px');
        } else {
          root.style.setProperty('--vh', window.innerHeight + 'px');
        }
      }
      updateVH();
      if (window.visualViewport) {
        visualViewport.addEventListener('resize', updateVH);
        visualViewport.addEventListener('scroll', updateVH);
      }
      window.addEventListener('orientationchange', updateVH);
      window.addEventListener('resize', updateVH);
    })();

    // --- Theme toggle (persisted) ---
    (function setupThemeToggle(){
      const KEY = 'nw-theme';
      const btn = document.getElementById('themeToggle');
      const root = document.documentElement;

      function labelFor(theme) {
        return theme === 'dark' ? '⋆｡ ﾟ☁︎｡ 𖤓 ⋆｡ ﾟ☁︎' : '⋆ ⁺  ₊  ⋆    ☾    ⋆  ⁺  ₊ ⋆';
      }
      function pressedFor(theme) {
        return theme === 'dark' ? 'true' : 'false';
      }
      function currentTheme() {
        return root.getAttribute('data-theme') || 'light';
      }
      function setTheme(theme) {
        root.setAttribute('data-theme', theme);
        try { localStorage.setItem(KEY, theme); } catch (_) {}
        btn.textContent = labelFor(theme);
        btn.setAttribute('aria-pressed', pressedFor(theme));
      }
      // Initialize button label/state
      setTheme(currentTheme());

      btn.addEventListener('click', () => {
        const next = currentTheme() === 'dark' ? 'light' : 'dark';
        setTheme(next);
      });
    })();

    // --- Basic config / helpers ---
    const SUPABASE_URL  = window.__TCFG?.SUPABASE_URL || "";
    const SUPABASE_ANON = window.__TCFG?.SUPABASE_ANON || "";
    if (!SUPABASE_URL || !SUPABASE_ANON) {
      alert("Missing Supabase config. Edit config.js and fill SUPABASE_URL and SUPABASE_ANON.");
    }

    // Hard-lock to a single room value that matches your DB 'messages.room'
    const ROOM = "default";

    const dom = (id)=>document.getElementById(id);
    function escapeHtml(s){ return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
    function scrollToBottom(){
      const frame = document.querySelector('main');
      frame.scrollTop = frame.scrollHeight;
    }

    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);

    // Persist name locally
    dom('name').value = localStorage.getItem('tinychat:name') || "";
    dom('name').addEventListener('input', e => localStorage.setItem('tinychat:name', e.target.value));

    let presenceChannel = null;
    let typingTimeout = null;
    let earliestLoaded = null; // timestamp of the oldest message currently shown

    // --- Presence as plain text list ---
    function renderPresence(state) {
      const names = Object.keys(state).sort();
      dom('presence').textContent = names.length ? `Present: ${names.join(', ')}` : 'Present: —';
    }

    function setupPresence(nameKey) {
      presenceChannel = supabase.channel('presence:' + ROOM, { config: { presence: { key: nameKey } } });

      presenceChannel.on('presence', { event: 'sync' }, () => {
        renderPresence(presenceChannel.presenceState());
      });

      presenceChannel.on('broadcast', { event: 'typing' }, ({ payload }) => {
        dom('typing').textContent = `${payload.name} is typing…`;
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => dom('typing').textContent = "", 900);
      });

      presenceChannel.subscribe(async (status) => {
        if (status === 'SUBSCRIBED') {
          await presenceChannel.track({ name: nameKey, at: Date.now() });
        }
      });
    }

    // --- Plain message line renderer ---
    function render(m, { prepend=false } = {}){
      const el = document.createElement('div');
      el.className = 'msg';
      const t = new Date(m.created_at).toLocaleTimeString();
      el.innerHTML = `<span class="time">[${t}]</span> <span class="name">${escapeHtml(m.user_name)}</span>: <span class="body">${escapeHtml(m.body)}</span>`;

      const log = dom('log');
      if (prepend) {
        const btn = dom('loadMore');
        if (btn && btn.nextSibling) log.insertBefore(el, btn.nextSibling);
        else log.appendChild(el);
      } else {
        log.appendChild(el);
      }
    }

    // --- Initial & paged loads (filter by ROOM) ---
    async function loadInitial() {
      const { data, error } = await supabase
        .from('messages')
        .select('*')
        .eq('room', ROOM)
        .order('created_at', { ascending: false })
        .limit(50);

      if (error) return;

      const arr = (data || []).slice().reverse(); // oldest -> newest for rendering
      arr.forEach(m => render(m));

      if (arr.length) {
        earliestLoaded = arr[0].created_at;      // oldest in the list
        dom('loadMore').style.display = 'inline-block';
      }
      scrollToBottom();
    }

    async function loadOlder() {
      if (!earliestLoaded) return;
      const { data, error } = await supabase
        .from('messages')
        .select('*')
        .eq('room', ROOM)
        .lt('created_at', earliestLoaded)
        .order('created_at', { ascending: false })
        .limit(50);

      if (error) return;

      const arr = (data || []).slice().reverse();
      arr.forEach(m => render(m, { prepend:true }));
      if (arr.length) earliestLoaded = arr[0].created_at;
      else dom('loadMore').disabled = true;
    }

    // --- Live inserts (listen only for this ROOM) ---
    supabase
      .channel('room:' + ROOM)
      .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: `room=eq.${ROOM}`
        },
        payload => { render(payload.new); scrollToBottom(); }
      )
      .subscribe();

    // --- Compose/send (insert with room: ROOM) ---
    dom('chat').addEventListener('submit', async (e) => {
      e.preventDefault();
      const name = dom('name').value.trim();
      const body = dom('body').value.trim();
      if (!name || !body) return;

      // naive spam throttle
      if (window.__lastSend && Date.now() - window.__lastSend < 800) return;
      window.__lastSend = Date.now();

      const { error } = await supabase.from('messages').insert({ room: ROOM, user_name: name, body });
      if (!error) {
        dom('body').value = '';
        dom('typing').textContent = "";
      }
    });

    dom('body').addEventListener('input', () => {
      const name = dom('name').value.trim() || 'guest';
      if (presenceChannel) {
        presenceChannel.send({ type: 'broadcast', event: 'typing', payload: { name } });
      }
    });

    // --- Boot ---
    (async () => {
      const nameKey = (localStorage.getItem('tinychat:name') || 'guest').slice(0, 32) || 'guest';
      setupPresence(nameKey);
      await loadInitial();
      dom('loadMore').addEventListener('click', loadOlder);
    })();
  </script>
</body>
</html>
